<!DOCTYPE html>
<html>
<head>
  <title>PSK / Shift-DC Encoder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; padding: 10px; max-width: 500px; margin: auto; }
    input, select, button, textarea { width: 100%; margin: 5px 0; padding: 8px; box-sizing: border-box; }
    textarea { height: 80px; }
  </style>
</head>
<body>
  <h2>PSK / Shift-DC Encoder</h2>

  <textarea id="textInput" placeholder="Enter text or binary..."></textarea>

  <label>Mode:</label>
  <select id="mode">
    <option value="psk">PSK</option>
    <option value="shift-dc">Shift-DC</option>
  </select>

  <label>Sample Rate:</label>
  <select id="sampleRate">
    <option>8000</option>
    <option>16000</option>
    <option>32000</option>
    <option>44100</option>
    <option selected>48000</option>
    <option>96000</option>
    <option>192000</option>
  </select>

  <label>Characters Per Minute (CPM):</label>
  <input type="number" id="cpm" value="60">

  <label>Stereo:</label>
  <select id="stereo">
    <option value="false">Mono</option>
    <option value="true">Stereo (Unstable)</option>
  </select>

  <button onclick="encodeText()">Encode</button>
  <button onclick="playAudio()">Play</button>
  <button onclick="stopAudio()">Stop</button>
  <button onclick="downloadWAV()">Download WAV</button>

  <script>
    let audioCtx, buffer, source;

    function encodeText() {
      const text = document.getElementById('textInput').value;
      if (!text) { alert("Enter some text to encode!"); return; }

      const mode = document.getElementById('mode').value;
      const cpm = parseInt(document.getElementById('cpm').value);
      const sampleRate = parseInt(document.getElementById('sampleRate').value);
      const stereo = document.getElementById('stereo').value === 'true';
      const bitDuration = 60 / (cpm * 8);
      const samplesPerBit = Math.floor(bitDuration * sampleRate);

      const binary = /^[01]+$/.test(text)
        ? text
        : text.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');

      const totalSamples = samplesPerBit * binary.length;
      const numChannels = stereo ? 2 : 1;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
      buffer = audioCtx.createBuffer(numChannels, totalSamples, sampleRate);

      let left = buffer.getChannelData(0);
      let right = stereo ? buffer.getChannelData(1) : null;
      let toggle = true;

      for (let i = 0; i < binary.length; i++) {
        const val = binary[i] === '1' ? 0.5 : -0.5;
        const start = i * samplesPerBit;

        if (stereo) {
          const target = toggle ? left : right;
          target.fill(val, start, start + samplesPerBit);
          toggle = !toggle;
        } else {
          left.fill(val, start, start + samplesPerBit);
        }
      }

      alert("Encoding complete!");
    }

    function playAudio() {
      if (!buffer) { alert("Encode something first!"); return; }
      source = audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(audioCtx.destination);
      source.start();
    }

    function stopAudio() {
      if (source) source.stop();
    }

    function downloadWAV() {
      if (!buffer) { alert("Encode something first!"); return; }

      const length = buffer.length;
      const sampleRate = buffer.sampleRate;
      const numChannels = buffer.numberOfChannels;
      const wavData = new DataView(new ArrayBuffer(44 + length * numChannels * 2));
      let offset = 0;

      function writeString(s) {
        for (let i = 0; i < s.length; i++) {
          wavData.setUint8(offset++, s.charCodeAt(i));
        }
      }

      function write16(val) { wavData.setInt16(offset, val, true); offset += 2; }
      function write32(val) { wavData.setUint32(offset, val, true); offset += 4; }

      writeString("RIFF");
      write32(36 + length * numChannels * 2);
      writeString("WAVE");
      writeString("fmt ");
      write32(16);
      write16(1);
      write16(numChannels);
      write32(sampleRate);
      write32(sampleRate * numChannels * 2);
      write16(numChannels * 2);
      write16(16);
      writeString("data");
      write32(length * numChannels * 2);

      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = buffer.getChannelData(ch)[i];
          wavData.setInt16(offset, sample * 32767, true);
          offset += 2;
        }
      }

      const blob = new Blob([wavData], { type: "audio/wav" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "encoded.wav";
      link.click();
    }
  </script>
</body>
</html>
